@page "/"
@implements IDisposable

<PageTitle>Home</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Pokedex!</MudText>

<div class="d-flex flex-column align-center">
    <MudPagination @ref="_mudPagination" SelectedChanged="PageChanged" Color="Color.Primary" Count="4" />
</div>

@if (pokemonList.Count >= _selectedPage * 12)
{

    int startIndex = (_selectedPage - 1) * 12;
    int endIndex = _selectedPage * 12;
    <MudGrid key="@renderKey">
        @for (var i = startIndex; i < endIndex; i++)
        {
            var pokemon = pokemonList[i];
            if (pokemon.Id != 0)
            {
                <MudItem xs="12" sm="6" md="4" lg="3" xl="2">
                    <MudImage Fluid="true" Src="@pokemon.FrontDefault" Alt="@pokemon.Name" />
                    <MudText Typo="Typo.caption">@ConvertToHashCode(pokemon.Id)</MudText>
                    <MudText Typo="Typo.h6">@pokemon.Name</MudText>
                    @for (var j = 0; j < pokemon.Types.Count; j++)
                    {
                        var type = pokemon.Types[j].Type.Name;
                        <MudChip Class="@GetChipClass(type)">@type</MudChip>
                    }
                </MudItem>
            }
        }
    </MudGrid>
}
else
{
    <div class="d-flex align-center justify-center">
        @for (var b = 0; b < 16; b++)
        {
            <br />
        }
        <span class="ring">
            Loading
            <span class="ringinside"></span>
        </span>
    </div>
}


@code {
    //var temp = await pokeClient.GetNamedResourcePageAsync<Pokemon>(12, 0);
    //https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/1.png
    private MudPagination _mudPagination;
    private int _selectedPage = 1;
    private int _pokemonListCount = 0;
    private string _pokemonListCountKey = "PokemonListCount";
    private string _pokemonListKey = "PokemonList";
    private string _selectedPageKey = "SelectedPage";
    List<PokemonLite> pokemonList = new List<PokemonLite>();
    PokeApiClient pokeClient = new PokeApiClient();
    private string renderKey = Guid.NewGuid().ToString();

    protected override async Task OnInitializedAsync()
    {

        if (await localStorage.ContainKeyAsync(_pokemonListCountKey))
        {
            _pokemonListCount = int.Parse(await localStorage.GetItemAsStringAsync(_pokemonListCountKey));
        }

        if (await localStorage.ContainKeyAsync(_pokemonListKey))
        {
            pokemonList = await localStorage.GetItemAsync<List<PokemonLite>>(_pokemonListKey);
        }
        else
        {
            await GetPokemonList(1);
        }

        if (await localStorage.ContainKeyAsync(_selectedPageKey))
        {
            _selectedPage = int.Parse(await localStorage.GetItemAsStringAsync(_selectedPageKey));
            _mudPagination.NavigateTo(_selectedPage - 1);
        }

    }

    private async Task GetPokemonList(int page)
    {
        _selectedPage = page;
        int startIndex = (page - 1) * 12 + 1;
        int endIndex = page * 12;

        // Skip first load of page 1
        if (pokemonList.Count() + 12 < endIndex)
        {
            for (var i = pokemonList.Count(); i < endIndex - 12; i++)
            {
                pokemonList.Add(new PokemonLite());
            }
        }

        for (var i = startIndex; i <= endIndex; i++)
        {
            // Check if click on page 3 and page 2 is empty
            if (pokemonList.Count() >= endIndex && pokemonList[i - 1] is PokemonLite && pokemonList[i - 1].Id == 0)
            {
                var getPokemon = await pokeClient.GetResourceAsync<Pokemon>(i);
                pokemonList[i - 1].Id = getPokemon.Id;
                pokemonList[i - 1].Name = getPokemon.Name;
                pokemonList[i - 1].FrontDefault = getPokemon.Sprites.Other.OfficialArtwork.FrontDefault;
                pokemonList[i - 1].Types = getPokemon.Types;
            }
            else
            {
                try
                {
                    // trick to not call api to check if pokemon exist
                    var _ = pokemonList[i - 1].Id;
                }
                catch (System.ArgumentOutOfRangeException)
                {
                    var getPokemon = await pokeClient.GetResourceAsync<Pokemon>(i);
                    pokemonList.Add(new PokemonLite()
                        {
                            Id = getPokemon.Id,
                            Name = getPokemon.Name,
                            FrontDefault = getPokemon.Sprites.Other.OfficialArtwork.FrontDefault,
                            Types = getPokemon.Types
                        });
                }
            }
        }
        // update the key to force a re-render
        renderKey = Guid.NewGuid().ToString();
        StateHasChanged();



        if (_pokemonListCount < pokemonList.Count)
        {
            _pokemonListCount = pokemonList.Count(x => x.Id != 0);
            await localStorage.SetItemAsStringAsync(_pokemonListCountKey, _pokemonListCount.ToString());
            await localStorage.SetItemAsync<List<PokemonLite>>(_pokemonListKey, pokemonList);
            Console.WriteLine(pokemonList.Count);
        }
    }

    private async void PageChanged(int i)
    {
        await localStorage.SetItemAsStringAsync(_selectedPageKey, i.ToString());
        await GetPokemonList(i).ConfigureAwait(false);
    }


    private string GetChipClass(string context)
    {
        context = context.ToLower();
        return $"background-color-{context}";
    }

    private static string ConvertToHashCode(int number)
    {
        return "#" + number.ToString().Trim().PadLeft(4, '0');
    }

    public void Dispose()
    {
        // dispose the client when the component is disposed
        pokeClient.Dispose();
    }
}